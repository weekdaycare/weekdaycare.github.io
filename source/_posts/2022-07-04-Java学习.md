---
title: Java学习
tags:
  - 代码
categories:
  - 学习
abbrlink: java-study
date: 2022-07-04 13:49:05
---

# 安装

第一步就踩坑，配置完环境变量之后报错，无法运行`JVM`

```bash
C:\Users\weekdaycare>java 
<JAVA_HOME>/lib/ext exists, extensions mechanism no longer supported; Use -classpath instead.
.Error: Could not create the Java Virtual Machine.
Error: A fatal exception has occurred. Program will exit.
```

一开始我以为是环境变量配置错了，结果实际上就是和报错说的一样，`<JAVA_HOME>/lib/ext exists`这个文件夹存在，去`java`安装目录中把`lib`文件夹中的`ext`文件夹删除即可

再次执行`java -version`没有报错了

```bash
C:\Users\weekdaycare>java -version
java version "17.0.3.1" 2022-04-22 LTS
Java(TM) SE Runtime Environment (build 17.0.3.1+2-LTS-6)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.3.1+2-LTS-6, mixed mode, sharing)
```

# Hello World！

编辑好初个`helloworld.java`文件后调用`javac`报错

```java
public class HelloWorld{
        public static void main(String[] args){
                System. out. println("Hello World!");
        }
}
```

报错（请把类名和文件名统一一下）

```java
helloworld.java:1: 错误: 类 HelloWorld 是公共的, 应在名为 HelloWorld.java 的文件中声明
public class HelloWorld{
       ^
1 个错误
```

把文件名改为`HelloWorld.java`再次运行就没有报错了

# 注释

编译`java`源程序时出现的错误： 编码 `GBK` 的不可映射字符 (0x80)的主要原因是，在编写`java`源程序代码时代码中添加了中文注释，且`java`文件的编码格式不是`ANSI`编码格式，导致在编译`java`源程序时报错，无法成功编译。

解决方案

编译的时候加上`-encoding utf-8`

```bash
javac -encoding utf-8 HelloWorld.java
```

或者直接把文件编码改为`ANSI`格式即可

# 常量分类

| 常量类型  | 说明         | 举例                |
|:-----:|:----------:|:-----------------:|
| 字符串常量 | 用双引号括起来的内容 | "HelloWorld" "你好" |
| 整数常量  | 不带小数的数字    | 666 -88           |
| 小数常量  | 带小数的数字     | 13.14 -5.21       |
| 字符常量  | 用单引号括起来的内容 | 'A' '0' '我'       |
| 布尔常量  | 布尔值，表示真假   | 只有两个值true false   |
| 空常量   | 一个特殊的值，空值  | 值为null            |

# 变量&数据类型

变量使用的注意事项：

1. 名字不能重复
2. 变量未赋值，不能使用
3. `long`类型的变量定义的时候，为了防止整数过大，后面要加`l`或`L`
4. `float`类型的变量定义的时候，为了防止类型不兼容，后面要加`f`或`F`

![数据类型.png](https://cdn.jsdelivr.net/gh/wefoox/pic/2022/08/29/16-39-54.webp "和C有点像")

![image.png](https://cdn.jsdelivr.net/gh/wefoox/pic/2022/08/29/16-40-00.webp)

> 注：`java`中默认整数为`int`型，浮点数默认为`double`型，见如下两个报错

## 整数太大

`long`定义变量后`javac`编译时遇到以下错误

```bash
HelloWorld.java:3: 错误: 整数太大
                long a = 999999999999;
                         ^
1 个错误
```

报错原因：在`java`中给出整数默认是`int`类型，导致数据越界

解决方案：定义`long`类型变量是要在数据之后加`l(L)`，例：

```java
long a = 999999999999l;
```

再次编译没有报错越界。

## 从double转换到float可能会有损失

`float`定义变量后编译报错

```bash
HelloWorld.java:4: 错误: 不兼容的类型: 从double转换到float可能会有损失
                float a = 13.14;
                          ^
1 个错误
```

报错原因：`java`中给出浮点数默认为`double`类型

解决方案：定义`double`类型变量要在数据后加`f(F)`，例：

```java
float a = 13.14f;
```

# 标识符&命名约定

1. 由数字、字母、下划线(_)和美元符($)组成
2. 不能以数字开头
3. 不能是关键字(比如`class`)
4. 区分大小写

## 小驼峰命名法：方法、变量

1. 标识符是一个单词的时候，首字母小写
   
   `name`

2. 约定2：标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写
   
   `firstName`

## 大驼峰命名法：类

1. 标识符是一个单词的时候， 首字母大写
   
   范例1：`Student`

2. 约定2：标识符由多个单词组成的时候，每个单词的首字母大写
   
   范例2：`GoodStudent`

# 类型转化

## 自动类型转化

把一个表示**数据范围小的数值**或者变量赋值给另一个表示**数据范围大的变量**

## 强制类型转化

把一个表示数据**范围大的数值**或者变量赋值给另一个表示**数据范围小的变量**

格式：目标数据类型变量名=(目标数据类型)值或者变量；

```java
public static void main(String[] args){
    //自动类型转化
    double a = 10;
    System. out. println(a);

    //定义byte类型变量
    byte b = 10;
    short s = b;
    int i = b;

    //这是不行的，类型不兼容
    //char c = b;

    //强制类型转化
    int k = (int)88.88;//数据丢失
}
```

# 运算符

## 算数运算符

- 运算符：对常量或者变量进行操作的**符号**
- 表达式：用**运算符**把常量或者变量连接起来**符合java语法的式子**就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式

> 整数相除只能得到整数，要想得到小数，必须有浮点数参与

字符的 `+` 操作：拿字符在计算机底层**对应的数值**来计算的

> 在`java`与`C语言`中都是将字符转化为`ASCII`编码

<details>
 <summary>常见的几种字符对应的ASCII编码</summary>

| 字符           | 编码  |
|:------------:|:---:|
| 'A'(A~Z是连续的) | 65  |
| 'a'(a~z是连续的) | 97  |
| '0'(0~9是连续的) | 48  |

</details>

**算术表达式中包含多个基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。**

提升规则：`byte`类型， `short`类型和`char`类型将被提升到`int`类型
整个表达式的类型自动提升到表达式中最高等级操作数同样的类型

> 等级顺序: `byte`,`short`,`char` →`int`→`long`→`float` → `double`

```java
public static void main(String[] args){
    //定义两个变量
    int i = 10;
    char c = 'A';//'A'的值是65
    c = 'a';//'a'的值是97
    c = '0';//'0'的值是48
    System. out. println(i + c);

    //char ch = i + c;
    //char类型会被自动提升为int类型
    int j = i + c;
    System. out. println(j);

    //int k = 10 + 13.14;
    double k = 10 + 13.14;
}
```

当 "+" 操作中出现字符串时，这个 "+" 是**字符串连接符**，而不是算术运算

<details>
<summary>示例代码</summary>

```java
public static void main(String[] args){
    System. out. println("hei"+"tui");
    System. out. println("heitui"+666);
    System. out. println(666+"heitui");
    System. out. println("heitui"+6+66);
    System. out. println(6+66+"heitui");
}
```

以上运行结果为

```java
heitui
heitui666
666heitui
heitui666
72heitui
```

</details>

## 赋值运算符

```java
public static void main(String[] args){
    //把10赋值给int类型的变量i
    int i = 10;
    System. out. println("i:" + i);

    // += 把左边和右边的数据做加法操作，结果赋值给左边
    i += 20;
    System. out. println("i:" + i);

    //注意：拓展的赋值运算符底层隐含了强制类型转化
    short s = 10;
    //s += 20;( += 操作默认强制类型转化)
    s = (short)(s + 20);
    System. out. println("s:" + s);
}
```

| 符号  | 作用    | 说明               |
|:---:|:-----:|:----------------:|
| =   | 赋值    | a=10，将10赋值给变量a   |
| +=  | 加后赋值  | a+=b，将a + b的值给a  |
| -=  | 减后赋值  | a-=b，将a - b的值给a  |
| *=  | 乘后赋值  | a*=b，将a × b的值给a  |
| /=  | 除后赋值  | a/=b，将a ÷ b的商给a  |
| %=  | 取余后赋值 | a%=b，将a ÷ b的余数给a |

> 注：拓展的赋值运算符底层**隐含**了强制类型转化

## 逻辑运算符

| 符号  | 作用   | 说明                                           |
|:---:|:----:|:--------------------------------------------:|
| &   | 逻辑与  | a&b，a和b都是true，结果为true，否则为false（有false则false） |
| \|  | 逻辑或  | a\|b，a和b都是false，结果为false，否则为true（有true则true） |
| ^   | 逻辑异或 | a^b，a和b结果相异为true，相同为false（相异为一）              |
| !   | 逻辑非  | !a，结果和a的结果正好相反                               |

## 短路逻辑运算符

| 符号   | 作用  | 说明              |
|:----:|:---:|:---------------:|
| &&   | 短路与 | 作用和&相同，但是有短路效果  |
| \|\| | 短路或 | 作用和\|相同，但是有短路效果 |

**注意事项：**

- 逻辑与**\&**，无论左边真假，右边都要执行
  短路与**\&\&**，如果左边为真，右边执行；如果**左边为假，右边不执行**
- 逻辑或**\|**，无论左边真假，右边都要执行
  短路或**\|**，如果左边为假，右边执行；如果**左边为真，右边不执行**

<details>
<summary>示例代码</summary>

```java
public static void main(String[] args){
    int i = 10;
    int j = 20; 
    //&&和&
    //System.out.println((i++>50)&(j++>50));//false & false
    System.out.println((i++>50)&&(j++>50));//false && false
    System.out.println("i:" + i);
    System.out.println("j:" + j);
}
```

运行结果为

```bash
false
i:11
j:20
```

可以发现`j++`没有执行，故为短路

</details>

## 三元运算符

- 格式：`关系表达式？表达式1：表达式2;`
- 范例：`a > b ? a : b;`（两个数据中的较大值）
- 计算规则：
  首先计算**关系表达式的值**
  如果值为**true，表达式1的值**就是运算结果
  如果值为**false，表达式2的值**就是运算结果

<details>
<summary>示例：三个和尚</summary>

```java
//输出三个中的最大值
public static void main(String[] args){
    int a = 160;
    int b = 210; 
    int c = 180;
    int MaxHeight = (a>b?a:b)>c?(a>b?a:b):c;
    System.out.println(MaxHeight);
}
```

</details>

# 数据输入

我一开始还天真的以为它跟C一样用`scanf`，但其实`Java`里根本没有`scanf`，倒是有个`Scanner`，`Scanner`类位于`java.util.Scanner`包中，因此在程序前面要加上此包

1. 导包
   
   ```java
   import java.until.Scanner;
   //导包的动作必须出现在类定义的上边(扔最上边)
   ```

2. 创建对象
   
   ```java
   Scanner sc = new Scanner(System.in);
   //上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变
   ```
   
   其中`Scanner sc = new Scanner(System.in);`这一句是关键。这一句的意思是：通过`new Scanner(System.in)`创建一个`Scanner`，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给`Scanner`，作为扫描对象

3. 接受数据
   然后如果想要获取输入的内容，就需要调用`Scanner`的`nextLine()`方法，因此就用到了`String name = in.nextLine()`，`int age = in.nextInt()`，`double height = in.nextDouble()`这三句来获取输入的内容
   
   ```java
   String name = sc.nextLine();//输入一整行，中间可以有空格
   int age = sc.nextInt();//整形
   double height = sc.nextDouble();//浮点型
   ```

<details>
<summary>具体代码示例：</summary>

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);//定义scanner，等待输入

    System.out.println("请输入你的姓名:");
    String name = in.nextLine();//字符(串)类型的输入方式
    System.out.println(name);

    System.out.println("请输入你的年龄：");
    int age = in.nextInt();//整数类型的输入方式
    System.out.println(age);

    System.out.println("请输入你的身高：");
    double height = in.nextDouble();//浮点类型的输入方式
    System.out.println(height);
}
```

</details>

> 但是这里面有一点需要注意一下，就是`nextLine()`方法会**吃回车符**，比如以下代码

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);//定义scanner，等待输入
    System.out.println("请输入你的姓名:");
    String name = in.nextLine();//字符类型的输入方式
    System.out.println(name);

    System.out.println("请输入你的年龄：");
    int age = in.nextInt();//整数类型的输入方式
    System.out.println(age);

    System.out.println("请输入苹果的英文：");
    //String s = in.next();
    String s = in.nextLine();
    System.out.println(s);

    System.out.println("请输入你的身高：");
    double height = in.nextDouble();//小数类型的输入方式
    System.out.println(height);
}
```

运行一下就会发现程序并没有让你输入苹果的英文，而是直接回车了，那是因为你输入完年龄之后的那个回车被`nextLine()`吃掉了，因此它并没有输出什么，但如果你用`in.next()`的话，它是可以输入的

<details>
<summary>两种运行结果</summary>

1. `in.nextLine()`
   
   ```bash
   请输入你的姓名:
   WO
   WO
   请输入你的年龄:
   12
   12
   请输入苹果的英文:
   ```

请输入你的身高:
134
134.0

```
2. `in.next()`
```bash
请输入你的姓名:
WO
WO
请输入你的年龄:
12
12
请输入苹果的英文:
apple
apple
请输入你的身高:
134
134.0
```

</details>

如果要输入带空格的字符串的话，可以添加`in.nextLine();`语句吃掉回车符，如下

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);//定义scanner，等待输入
    System.out.println("请输入你的姓名:");
    String name = in.nextLine();//字符类型的输入方式
    System.out.println(name);

    System.out.println("请输入你的年龄：");
    int age = in.nextInt();//整数类型的输入方式
    System.out.println(age);

    System.out.println("请输入苹果的英文：");
    //String s = in.next();
    in.nextLine(); //吃掉回车符
    String s = in.nextLine();
    System.out.println(s);

    System.out.println("请输入你的身高：");
    double height = in.nextDouble();//小数类型的输入方式
    System.out.println(height);
}
```

> 补充一下`nextLine()`和`next()`的区别：
> `nextLine()`方法返回的是`Enter`键之前的所有字符，它是可以得到带空格的字符串的
> `next()`会自动消去有效字符前的空格，只返回输入的字符，不能得到带空格的字符串

# Switch语句

> **注**：在`switch`语句中，如果`case`控制的语句体后面不写`break`，将出现**穿透现象**，在不判断下一个`case`值的情况下，向下运行，直到遇到`break`，或者整体`switch`语句结束（这点与C语言相同）

# 循环

**三种循环的区别：**

- `for`循环和`while`循环先判断条件是否成立，然后决定是否执行循环体(先判断后执行)
- `do...while`循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体(先执行后判断)

**`for`和`while`的区别：**

- 条件控制语句所控制的自增变量，因为归属`for`循环的语法结构中，在`for`循环结束后，就不能再次被访问到了
- 条件控制语句所控制的自增变量，对于`while`循环来说不归属其语法结构中，在`while`循环结束后，该变量还可以继续使用

**死循环格式：**
`for(;;) { }`
`while(true) { }`
`do{ }while(true);`

`while`的死循环格式是最常用的
命令提示符窗口中`CtrI + C`可以结束死循环

---

目前开学了，转学`Python`，`JAVA`暂时搁置一段时间
